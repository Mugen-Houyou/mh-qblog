[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "안녕하세요. 무한포옹 《無限抱擁》입니다.",
    "section": "",
    "text": "Quarto 블로그 플랫폼을 기반으로 제작한, 무한포옹의 새로운 블로그입니다. 환영합니다!"
  },
  {
    "objectID": "posts/2024.3.19. Elasticsearch 및 Kibana/2024.3.19. Elasticsearch 및 Kibana.html",
    "href": "posts/2024.3.19. Elasticsearch 및 Kibana/2024.3.19. Elasticsearch 및 Kibana.html",
    "title": "Elasticsearch 및 Kibana",
    "section": "",
    "text": "🏷️ Tags: #03-2024 #NoSQL\n\n\n\n\nElasticsearch이란?\n\n\n\n\n\n\n\n\nKibana란?"
  },
  {
    "objectID": "posts/2024.3.19. Elasticsearch 및 Kibana/2024.3.19. Elasticsearch 및 Kibana.html#elasticsearch-개요",
    "href": "posts/2024.3.19. Elasticsearch 및 Kibana/2024.3.19. Elasticsearch 및 Kibana.html#elasticsearch-개요",
    "title": "Elasticsearch 및 Kibana",
    "section": "",
    "text": "Elasticsearch이란?"
  },
  {
    "objectID": "posts/2024.3.19. Elasticsearch 및 Kibana/2024.3.19. Elasticsearch 및 Kibana.html#kibana-개요",
    "href": "posts/2024.3.19. Elasticsearch 및 Kibana/2024.3.19. Elasticsearch 및 Kibana.html#kibana-개요",
    "title": "Elasticsearch 및 Kibana",
    "section": "",
    "text": "Kibana란?"
  },
  {
    "objectID": "posts/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동.html",
    "href": "posts/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동.html",
    "title": "Jenkins 및 Pipeline으로 GitHub 연동",
    "section": "",
    "text": "🏷️Tags : #02-2024 #CI_CD #CI_CD/Jenkins\n\n\n\n\nJenkins 로고.\n\n\n\n\n\nGitHub에 fisa240220_2 레포지터리 생성\nSpring로 간단하게 step07_citest 프로젝트 생성\n\nGET 요청 처리 메서드 하나만 구현\n\nJenkins에 새 item 개발\n\nitem명: step04review\n방법:\n\nJenkins 구동 ==&gt; Dashboard ==&gt; Enter an item name에 step04review ==&gt; pipeline 선택\n==&gt; General의 Description 항목에 대충 설명 입력\n==&gt; Pipeline script 선택 ==&gt; GitHub + Maven 선택\n==&gt; Pipeline Syntax 클릭\n  ==&gt; Repo. URL 입력, Branch 선택, Credentials 구성, \n  ==&gt; Generate Pipeline Script 클릭 ==&gt; 내용 복사\n==&gt; 위 내용 복사해서 steps에 붙여넣기\n==&gt; Maven 항목 주석 처리, JUnit 테스트 관련 항목 주석 처리\n==&gt; 상황에 밎추어 작성, 완성 후 Save 클릭\n==&gt; 이후 빌드, 결과 확인\n==&gt; git ls-tree HEAD로 git에 저장된 권한 확인\n==&gt; git update-index --add --chmod=o-x gradlew로 x 권한 부여\n\n\n이를 통해 step03처럼 ls -al 시 아래와 같이 나와야 함: -rwxr-xr-x 1 jenkins jenkins 2776 Feb 20 05:12 gradlew.bat\n\n참고: gradlew 파일이 윈도우에서 생성 시에는 읽기만 가능한 권한으로 생성\n\n\n\n\n\n\nPipeline 예시 코드:\n\npipeline {\n    agent any\n    \n    stages {\n        stage('Build') {\n            steps {\n                git branch:'master',\n                credentialsId: '&lt;EXAMPLE_CREDENTIALS_ID&gt;', \n                url: 'https://github.com/Mugen-Houyou/fisa240220_2.git'\n            }\n\n            post {\n                // If Maven was able to run the tests, even if some of the test\n                // failed, record the test results and archive the jar file.\n                success {\n                    // junit '**/target/surefire-reports/TEST-*.xml'\n                    // archiveArtifacts 'target/*.jar'\n                    echo \"success!\"\n                }\n            }\n        }\n        stage('list view') {\n            steps {\n                echo 'now showing contents'\n                sh '''whoami'''\n                sh '''pwd'''\n                sh '''ls -al'''\n                echo 'finished showing contents'\n            }\n        }\n    }\n}\n\n\n\n\ngit bash, jenkins item 생성, GH 활용, gradle 주의사항."
  },
  {
    "objectID": "posts/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동.html#금일-과제",
    "href": "posts/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동.html#금일-과제",
    "title": "Jenkins 및 Pipeline으로 GitHub 연동",
    "section": "",
    "text": "GitHub에 fisa240220_2 레포지터리 생성\nSpring로 간단하게 step07_citest 프로젝트 생성\n\nGET 요청 처리 메서드 하나만 구현\n\nJenkins에 새 item 개발\n\nitem명: step04review\n방법:\n\nJenkins 구동 ==&gt; Dashboard ==&gt; Enter an item name에 step04review ==&gt; pipeline 선택\n==&gt; General의 Description 항목에 대충 설명 입력\n==&gt; Pipeline script 선택 ==&gt; GitHub + Maven 선택\n==&gt; Pipeline Syntax 클릭\n  ==&gt; Repo. URL 입력, Branch 선택, Credentials 구성, \n  ==&gt; Generate Pipeline Script 클릭 ==&gt; 내용 복사\n==&gt; 위 내용 복사해서 steps에 붙여넣기\n==&gt; Maven 항목 주석 처리, JUnit 테스트 관련 항목 주석 처리\n==&gt; 상황에 밎추어 작성, 완성 후 Save 클릭\n==&gt; 이후 빌드, 결과 확인\n==&gt; git ls-tree HEAD로 git에 저장된 권한 확인\n==&gt; git update-index --add --chmod=o-x gradlew로 x 권한 부여\n\n\n이를 통해 step03처럼 ls -al 시 아래와 같이 나와야 함: -rwxr-xr-x 1 jenkins jenkins 2776 Feb 20 05:12 gradlew.bat\n\n참고: gradlew 파일이 윈도우에서 생성 시에는 읽기만 가능한 권한으로 생성"
  },
  {
    "objectID": "posts/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동.html#예시-코드",
    "href": "posts/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동.html#예시-코드",
    "title": "Jenkins 및 Pipeline으로 GitHub 연동",
    "section": "",
    "text": "Pipeline 예시 코드:\n\npipeline {\n    agent any\n    \n    stages {\n        stage('Build') {\n            steps {\n                git branch:'master',\n                credentialsId: '&lt;EXAMPLE_CREDENTIALS_ID&gt;', \n                url: 'https://github.com/Mugen-Houyou/fisa240220_2.git'\n            }\n\n            post {\n                // If Maven was able to run the tests, even if some of the test\n                // failed, record the test results and archive the jar file.\n                success {\n                    // junit '**/target/surefire-reports/TEST-*.xml'\n                    // archiveArtifacts 'target/*.jar'\n                    echo \"success!\"\n                }\n            }\n        }\n        stage('list view') {\n            steps {\n                echo 'now showing contents'\n                sh '''whoami'''\n                sh '''pwd'''\n                sh '''ls -al'''\n                echo 'finished showing contents'\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "posts/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동.html#학습",
    "href": "posts/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동/2024.2.20. Jenkins 및 Pipeline으로 GitHub 연동.html#학습",
    "title": "Jenkins 및 Pipeline으로 GitHub 연동",
    "section": "",
    "text": "git bash, jenkins item 생성, GH 활용, gradle 주의사항."
  },
  {
    "objectID": "posts/2024.1.30. 현장실습/2024.1.30. 현장실습.html",
    "href": "posts/2024.1.30. 현장실습/2024.1.30. 현장실습.html",
    "title": "2024.1.30. 현장실습",
    "section": "",
    "text": "고객\n은행: ‘락인 (Lock-in) 효과’\n정부\n\n\n\n\n\n마이데이터 서비스\n\nJava, QCELL, DevOn\n\n데이터 송수신 허브\n\nJava, Kafka, DevOn\n\n마이데이터 DB\n\n번외 - 마이데이터 기반의 내 데이터 상거래 서비스? - 자바 개발자가 부족하다: 자바, 파이썬, SQL 등. - 비즈니스에 대한 이해가 필요.\n\n\n\n\n\n\n\n\n\n\n개방형 (Public) 블록체인\n허가형 (Private) 블록체인\n컨소시엄 블록체인\n\n\n\n\n\n뱅크사인 서비스\n\n블록체인 기반 은행권 공동 인증서\n옛 공인인증서 대체를 위해 은행연합회 주도로 구축\n\n뱅크아이디 서비스\n\n위 뱅크사인이 널리 사용되지는 않음\n그래서 새로 DID (Decentralized Identifier) 기술을 도입 및 리뉴얼\n예시: COOV (코로나 백신 앱)\n\n우리은행 블록체인 플랫폼\n\n하이퍼레저 패브릭을 기반으로, 우리은행만의 시스템\nJava, Go, Node.js 등 일반적인 프로그래밍 언어를 사용\n변호사자격증, 운전면허증, 장병 자격증명, 공무원연금공단 추천서 발급 및 검증 등\nNFT, CBDC (Central Bank DIgital Currency)\n\n토큰 증권 플랫폼\n\n토큰 증권이란?\n\n\n말 그대로 모든 자산의 상품화.\n\n분산원장 기술 등을 통해 자본시장법상 증권을 디지털화한 것\n법제적으로는 전자증권에 해당\n우리종합금융이 추진 중인 증권사와의 시너지와 관련 있음 ==&gt; 심혈을 기울이는 사업.\n\n\n\n\n\n\n개발: dApp 서비스 및 스마트 컨트랙트 개발\n\n블록체인 기반, 그러나 모든 비즈니스를 다 넣을 수는 없기에, 블록체인 연계해서 서비스 개발을 해야 한다. 업무 로직을 개발하고, 블록체인으로 연계하기.\n\n인프라: OS, DB, 네트워크, Docker 등\n보안: 공개키-개인키 관리, 전자서명\n비즈니스: 해당 직무상 비즈니스\n\n\n\n\n\n면접에서는 블록체인 원리 자체보다는 업에서 어떻게 활용할 것인지 등 설명.\n커뮤니케이션 스킬이 중요\n\n\n\n\n\n\n\n\n\n\n\n\n디지털금융서비스 개요\n\n트렌드\n\n이종 산업간 협업\n예) 편의점 배달 서비스 인앱화\n\n\n디지털금융업무 시스템의 이해\n\n워크플로\n\n채널 (대면/인터넷/스마트 등) ==&gt; 서버 ==&gt; 호스트 (관련 원장)\n\nSI/SM"
  },
  {
    "objectID": "posts/2024.1.30. 현장실습/2024.1.30. 현장실습.html#특강-1-마이데이터-0910-1000",
    "href": "posts/2024.1.30. 현장실습/2024.1.30. 현장실습.html#특강-1-마이데이터-0910-1000",
    "title": "2024.1.30. 현장실습",
    "section": "",
    "text": "고객\n은행: ‘락인 (Lock-in) 효과’\n정부\n\n\n\n\n\n마이데이터 서비스\n\nJava, QCELL, DevOn\n\n데이터 송수신 허브\n\nJava, Kafka, DevOn\n\n마이데이터 DB\n\n번외 - 마이데이터 기반의 내 데이터 상거래 서비스? - 자바 개발자가 부족하다: 자바, 파이썬, SQL 등. - 비즈니스에 대한 이해가 필요."
  },
  {
    "objectID": "posts/2024.1.30. 현장실습/2024.1.30. 현장실습.html#블록체인의-개념",
    "href": "posts/2024.1.30. 현장실습/2024.1.30. 현장실습.html#블록체인의-개념",
    "title": "2024.1.30. 현장실습",
    "section": "",
    "text": "개방형 (Public) 블록체인\n허가형 (Private) 블록체인\n컨소시엄 블록체인\n\n\n\n\n\n뱅크사인 서비스\n\n블록체인 기반 은행권 공동 인증서\n옛 공인인증서 대체를 위해 은행연합회 주도로 구축\n\n뱅크아이디 서비스\n\n위 뱅크사인이 널리 사용되지는 않음\n그래서 새로 DID (Decentralized Identifier) 기술을 도입 및 리뉴얼\n예시: COOV (코로나 백신 앱)\n\n우리은행 블록체인 플랫폼\n\n하이퍼레저 패브릭을 기반으로, 우리은행만의 시스템\nJava, Go, Node.js 등 일반적인 프로그래밍 언어를 사용\n변호사자격증, 운전면허증, 장병 자격증명, 공무원연금공단 추천서 발급 및 검증 등\nNFT, CBDC (Central Bank DIgital Currency)\n\n토큰 증권 플랫폼\n\n토큰 증권이란?\n\n\n말 그대로 모든 자산의 상품화.\n\n분산원장 기술 등을 통해 자본시장법상 증권을 디지털화한 것\n법제적으로는 전자증권에 해당\n우리종합금융이 추진 중인 증권사와의 시너지와 관련 있음 ==&gt; 심혈을 기울이는 사업.\n\n\n\n\n\n\n개발: dApp 서비스 및 스마트 컨트랙트 개발\n\n블록체인 기반, 그러나 모든 비즈니스를 다 넣을 수는 없기에, 블록체인 연계해서 서비스 개발을 해야 한다. 업무 로직을 개발하고, 블록체인으로 연계하기.\n\n인프라: OS, DB, 네트워크, Docker 등\n보안: 공개키-개인키 관리, 전자서명\n비즈니스: 해당 직무상 비즈니스\n\n\n\n\n\n면접에서는 블록체인 원리 자체보다는 업에서 어떻게 활용할 것인지 등 설명.\n커뮤니케이션 스킬이 중요"
  },
  {
    "objectID": "posts/2024.1.30. 현장실습/2024.1.30. 현장실습.html#특강-5-디지털금융서비스",
    "href": "posts/2024.1.30. 현장실습/2024.1.30. 현장실습.html#특강-5-디지털금융서비스",
    "title": "2024.1.30. 현장실습",
    "section": "",
    "text": "디지털금융서비스 개요\n\n트렌드\n\n이종 산업간 협업\n예) 편의점 배달 서비스 인앱화\n\n\n디지털금융업무 시스템의 이해\n\n워크플로\n\n채널 (대면/인터넷/스마트 등) ==&gt; 서버 ==&gt; 호스트 (관련 원장)\n\nSI/SM"
  },
  {
    "objectID": "posts/2024.1.25. VMware 마이그레이션/2024.1.25. VMware 마이그레이션.html",
    "href": "posts/2024.1.25. VMware 마이그레이션/2024.1.25. VMware 마이그레이션.html",
    "title": "VMware 마이그레이션",
    "section": "",
    "text": "미완성 노트"
  },
  {
    "objectID": "posts/2024.1.25. VMware 마이그레이션/2024.1.25. VMware 마이그레이션.html#cold-vs.-hot-migrations",
    "href": "posts/2024.1.25. VMware 마이그레이션/2024.1.25. VMware 마이그레이션.html#cold-vs.-hot-migrations",
    "title": "VMware 마이그레이션",
    "section": "Cold vs. Hot Migrations",
    "text": "Cold vs. Hot Migrations\n\nCold Migrations?\nVM들의 전원을 종료하거나 suspend 후 마이그레이션하는 것. - Intel vs. AMD ==&gt; 명령어 세트가 달라지면 hot이 어려울 수 있음.\n\n\nHot Migrations?\nVM들의 전원이 켜진 상태에서 disruptions나 downtime 없이 마이그레이션하는 것. - 전용 vMotion 네트워크를 구성하여, 마이그레이션 전에 데이터를 옮김. - 이때 vSwitch에서는 VMkernel port를 이용.\n\n\nShared Storage\n\n양쪽 호스트가 다 연결되어 있고,"
  },
  {
    "objectID": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html",
    "href": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html",
    "title": "2024.1.19. 다이나믹 라우팅：OSPF (실습)",
    "section": "",
    "text": "아래는 sh ip ospf nei 실행 시 나오는 화면."
  },
  {
    "objectID": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html#부가-ospf-구성-시-neighbor-id-state-drotherbdrdr",
    "href": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html#부가-ospf-구성-시-neighbor-id-state-drotherbdrdr",
    "title": "2024.1.19. 다이나믹 라우팅：OSPF (실습)",
    "section": "",
    "text": "아래는 sh ip ospf nei 실행 시 나오는 화면."
  },
  {
    "objectID": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html#ipv6-관련-공부해야-할-것들",
    "href": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html#ipv6-관련-공부해야-할-것들",
    "title": "2024.1.19. 다이나믹 라우팅：OSPF (실습)",
    "section": "IPv6 관련 공부해야 할 것들:",
    "text": "IPv6 관련 공부해야 할 것들:\n\nICMPv6: 단순히 핑뿐만 아니라 MAC 주소도 같이 갖고 온다 등\n주소 종류: Unicast, link-local\n주소 할당 방식\n[심화] IPv4 ==&gt; IPv6 migration 방법"
  },
  {
    "objectID": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html#ipv6의-link-local-주소",
    "href": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html#ipv6의-link-local-주소",
    "title": "2024.1.19. 다이나믹 라우팅：OSPF (실습)",
    "section": "IPv6의 link local 주소",
    "text": "IPv6의 link local 주소\n구현된 토폴로지:\nR1에서:\nconf t\nint e0/0\nipv6 address 2001:DB8:1111:2::1/64\nno shut\nR2에서:\nconf t\nint e0/0\nipv6 address 2001:DB8:1111:2::2/64\nno shut\n\nFE80으로 시작함.\n기존의 IPv4는, 단일 IP 주소를 사용하여 네트워크 통신을 수행. 이 때문에 운용 도중에 IPv4 주소를 바꿔버리면 통신이 그냥 끊어져버림.\n그러나 IPv6은 위 link local 주소 덕분에 장치 간의 로컬 네트워크 내에서 계속해서 통신할 수 있는 기본 수단을 제공하므로, 주소가 도중에 바뀌더라도 통신을 계속할 수 있음."
  },
  {
    "objectID": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html#ipv6의-주소-할당",
    "href": "posts/2024.1.19. 다이나믹 라우팅：OSPF (실습)/2024.1.19. 다이나믹 라우팅：OSPF (실습).html#ipv6의-주소-할당",
    "title": "2024.1.19. 다이나믹 라우팅：OSPF (실습)",
    "section": "IPv6의 주소 할당",
    "text": "IPv6의 주소 할당\n\nStatic\nDHCPv6\nEUI-64\nStateless autoconfig"
  },
  {
    "objectID": "posts/2024.1.17. VirtualBox의 VM에서 내부망으로 연결/2024.1.17. VirtualBox의 VM에서 내부망으로 연결.html",
    "href": "posts/2024.1.17. VirtualBox의 VM에서 내부망으로 연결/2024.1.17. VirtualBox의 VM에서 내부망으로 연결.html",
    "title": "2024.1.17. VirtualBox의 VM에서 내부망으로 연결",
    "section": "",
    "text": "노트 작성 일자: 2024년 1월 17일 (수) 11:25"
  },
  {
    "objectID": "posts/2024.1.17. VirtualBox의 VM에서 내부망으로 연결/2024.1.17. VirtualBox의 VM에서 내부망으로 연결.html#virtualbox-네트워크-관리자",
    "href": "posts/2024.1.17. VirtualBox의 VM에서 내부망으로 연결/2024.1.17. VirtualBox의 VM에서 내부망으로 연결.html#virtualbox-네트워크-관리자",
    "title": "2024.1.17. VirtualBox의 VM에서 내부망으로 연결",
    "section": "VirtualBox 네트워크 관리자",
    "text": "VirtualBox 네트워크 관리자\n\n아래와 같이 구성:"
  },
  {
    "objectID": "posts/2024.1.17. VirtualBox의 VM에서 내부망으로 연결/2024.1.17. VirtualBox의 VM에서 내부망으로 연결.html#ubuntu-가상-머신",
    "href": "posts/2024.1.17. VirtualBox의 VM에서 내부망으로 연결/2024.1.17. VirtualBox의 VM에서 내부망으로 연결.html#ubuntu-가상-머신",
    "title": "2024.1.17. VirtualBox의 VM에서 내부망으로 연결",
    "section": "Ubuntu 가상 머신",
    "text": "Ubuntu 가상 머신\n\n게스트 머신을 클릭 후 설정에서, 네트워크 탭을 선택하고, 어댑터 중 하나를 아래와 같이 구성: \n이러면 게스트 머신은 VirtualBox Host-Only Ethernet Adapter와 연결은 됨\n그러나 IP 주소 등은 유저가 직접 구성해야 함\n먼저, 게스트 머신이 VirtualBox Host-Only Ethernet Adapter와 연결된 NIC를 identify하기 위해 ip addr를 입력:\n\n여기서는 enp0s8 인터페이스라고 가정하겠음\n\n그 다음, 우분투 22.04 기준으로, VM의 전원을 켜고 아래와 같이 입력:\n\nsudo nano /etc/netplan/01-netcfg.yaml\n\n해당 야믈 파일을 아래와 같이 구성 - 여기서는 192.168.56.2을 assign함:\n\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    enp0s8:\n      dhcp4: no\n      addresses:\n        - 192.168.56.2/24\n      gateway4: 192.168.56.1\n      nameservers:\n        addresses: [9.9.9.9, 1.1.1.1]\n\n이후 sudo netplan apply로 해당 야믈 파일을 실제로 반영\n참고: /etc/netplan/01-netcfg.yaml는 무얼 하는 파일인가?\n\nA configuration file to define the way your system connects to the network, used by Netplan, which is a utility for network configuration management in modern Ubuntu versions (starting from 17.10).\nAfter editing this file, the command sudo netplan apply is used to apply the changes. Netplan reads the YAML file, generates the appropriate configuration for the underlying system (e.g., systemd-networkd), and applies it to the network interfaces.\n00, 01, 02, … ==&gt; The 01 in 01-netcfg.yaml implies priority or order of processing. Netplan processes files in lexicographic order. This means you can have multiple configuration files for different purposes, and they will be processed in order based on their filenames.\nIt replaces older methods of network configuration, like editing /etc/network/interfaces in previous versions of Ubuntu.\n여기서 gateway4와 nameservers는 외부망 (인터넷)으로 연결하려면 필수.\n\n반영 후 ip addr를 통해 해당 IP 주소가 실제로 배정되었는지 확인:"
  },
  {
    "objectID": "posts/2024.1.16. VLAN 및 Static Routing 미션/2024.1.16. VLAN 및 Static Routing 미션.html",
    "href": "posts/2024.1.16. VLAN 및 Static Routing 미션/2024.1.16. VLAN 및 Static Routing 미션.html",
    "title": "2024.1.16. VLAN 및 Static Routing 미션",
    "section": "",
    "text": "노트 작성 일자: 2024년 1월 16일 (수) 15:58"
  },
  {
    "objectID": "posts/2024.1.16. VLAN 및 Static Routing 미션/2024.1.16. VLAN 및 Static Routing 미션.html#구현-후-topology",
    "href": "posts/2024.1.16. VLAN 및 Static Routing 미션/2024.1.16. VLAN 및 Static Routing 미션.html#구현-후-topology",
    "title": "2024.1.16. VLAN 및 Static Routing 미션",
    "section": "구현 후 Topology",
    "text": "구현 후 Topology"
  },
  {
    "objectID": "posts/2024.1.15. Layer 2 & Layer 3/2024.1.15. Layer 2 & Layer 3.html",
    "href": "posts/2024.1.15. Layer 2 & Layer 3/2024.1.15. Layer 2 & Layer 3.html",
    "title": "2024.1.15. Layer 2 & Layer 3",
    "section": "",
    "text": "노트 작성 일자: 2024년 1월 15일 (수) 22:49"
  },
  {
    "objectID": "posts/2024.1.15. Layer 2 & Layer 3/2024.1.15. Layer 2 & Layer 3.html#설명",
    "href": "posts/2024.1.15. Layer 2 & Layer 3/2024.1.15. Layer 2 & Layer 3.html#설명",
    "title": "2024.1.15. Layer 2 & Layer 3",
    "section": "설명",
    "text": "설명\n\nLayer 2?\n\n프레임을 이용.\nMAC 주소 기반으로 데이터 전송을 관리.\n스위치와 브리지 같은 장비가 이 계층에서 작동.\n오류 검출, 재전송, 흐름 제어 등의 기능을 담당.\n\nLayer 3?\n\n데이터 패킷을 이용.\nIP 주소를 기반으로 다른 네트워크로 데이터를 전송.\n라우터 등 장비가 해당.\n경로 결정(routing), 주소 지정(addressing), 패킷 분할(segmentation) 등."
  },
  {
    "objectID": "posts/2024.1.15. Layer 2 & Layer 3/2024.1.15. Layer 2 & Layer 3.html#collision-domain-및-broadcast-domain",
    "href": "posts/2024.1.15. Layer 2 & Layer 3/2024.1.15. Layer 2 & Layer 3.html#collision-domain-및-broadcast-domain",
    "title": "2024.1.15. Layer 2 & Layer 3",
    "section": "Collision Domain 및 Broadcast Domain",
    "text": "Collision Domain 및 Broadcast Domain\n\n1개 세그먼트로 여러 데이터가 전송될 때 충돌 발생 ==&gt; Collision domain.\n브로드캐스트가 닿는 네트워크의 범위 ==&gt; Broadcast domain."
  },
  {
    "objectID": "posts/2024.1.15. Layer 2 & Layer 3/2024.1.15. Layer 2 & Layer 3.html#vlan",
    "href": "posts/2024.1.15. Layer 2 & Layer 3/2024.1.15. Layer 2 & Layer 3.html#vlan",
    "title": "2024.1.15. Layer 2 & Layer 3",
    "section": "VLAN",
    "text": "VLAN\n\n가상 LAN.\n곧, N개의 broadcast domains = N개의 logical subnetworks."
  },
  {
    "objectID": "posts/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8.html",
    "href": "posts/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8.html",
    "title": "2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8",
    "section": "",
    "text": "스터디 및 노트 작성 일자: 2024년 1월 10일 (수) 22:04\n\n\n\nRHEL 7, 8 모두 Systemd를 사용하여 부팅, 시스템 서비스를 관리.\nRHEL 8부터 Cockpit라는 웹 콘솔을 기본으로 포함\n\n‘터미널 = 웹 콘솔’ 수준의 활용도 (터미널에서 수행된 작업이 웹 콘솔에도 즉시 반영)\n다만 RHEL 7에서도 따로 설치해서 이용하는 것이 가능.\n\nRHEL 8부터 Application Streams를 통한 모듈러 구조를 채택.\n\nhttps://www.thegeekdiary.com/beginners-guide-to-managing-package-module-streams-in-centos-rhel-8/\nhttps://access.redhat.com/documentation/ko-kr/red_hat_enterprise_linux/8/html/installing_managing_and_removing_user-space_components/introduction-to-modules_using-appstream#module-streams_introduction-to-modules\nhttps://access.redhat.com/documentation/ko-kr/red_hat_enterprise_linux/8/html/installing_managing_and_removing_user-space_components/installing-a-module-stream_installing-rhel-8-content\nhttps://unix.stackexchange.com/questions/603905/what-is-the-difference-between-a-yum-group-and-a-yum-module-in-red-hat-enterpris ## 네트워크\n\n네트워크 관리 방법이 서로 다름.\nRHEL 7은 network라는 서비스를 사용, network-scripts라는 스크립트를 작성함.\nRHEL 8은 NetworkManager라는 서비스를 사용 ==&gt; nmcli를 통해 관리. 예시) 네트워크 명명 규칙:\nRHEL 7에서: eth0 등.\nRHEL 8은 ’예측 가능한 네트워크 명명 규칙’을 도입 ==&gt; 가령, enpXXX (예: enp0s3) 형식을 사용.\nhttps://access.redhat.com/documentation/ko-kr/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index#consistent-network-interface-device-naming_configuring-and-managing-networking\n\n\n\n\n\nRHEL 7의 network-scripts 스크립트로 관리하기:\n\nDEVICE=eth0\nBOOTPROTO=static\nONBOOT=yes\nIPADDR=192.168.1.100\nNETMASK=255.255.255.0\nGATEWAY=192.168.1.1\nDNS1=8.8.8.8\nDNS2=8.8.4.4\n\nRHEL 8의 NetworkManager로 관리하기 (nmcli):\n\nnmcli device status\nnmcli con mod eth0 ipv4.addresses 192.168.1.100/24\nnmcli con mod eth0 ipv4.gateway 192.168.1.1\nnmcli con mod eth0 ipv4.dns \"8.8.8.8,8.8.4.4\"\nnmcli con mod eth0 ipv4.method manual\nnmcli con mod eth0 connection.autoconnect yes\nnmcli con down eth0\nnmcli con up eth0\n\n\n\n\nRHEL 7은 Docker 기반의 컨테이너화를 지원.\nRHEL 8은 Podman 등 기반의 컨테이너화를 지원. ## 스터디에서 RHEL 7 채택 이유\n금융권뿐만 아니라 대규모 시스템에서는 사후지원 종료 후에도 유지하는 경우가 많음.\n시스템의 안정성 및 기존 기술의 숙련. ## 다음 주 화요일까지?\n구글 트렌드, 스택오버플로 자료량, 깃허브 스타 등.\n화요일 ==&gt; 1시간 전체 PPT 발표, 수요일==&gt; 실습.\n화요일 주제: ESXi에 설치하기 위한 가상매모리, UEFI 등, 고려해야 할 요소?\n\n시스템 요구사항: RHEL 7의 요구되는 하드웨어 사양?\n네트워크 설정: VMWare 환경에서 RHEL 7의 네트워크 구성?\n스토리지 관리: 사용할 스토리지 타입 및 구성 방법?\n가상화 특성 고려: RHEL 7을 VMWare ESXi에 설치할 때 가상화 특성 및 호환성?"
  },
  {
    "objectID": "posts/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8.html#시스템",
    "href": "posts/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8.html#시스템",
    "title": "2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8",
    "section": "",
    "text": "RHEL 7, 8 모두 Systemd를 사용하여 부팅, 시스템 서비스를 관리.\nRHEL 8부터 Cockpit라는 웹 콘솔을 기본으로 포함\n\n‘터미널 = 웹 콘솔’ 수준의 활용도 (터미널에서 수행된 작업이 웹 콘솔에도 즉시 반영)\n다만 RHEL 7에서도 따로 설치해서 이용하는 것이 가능.\n\nRHEL 8부터 Application Streams를 통한 모듈러 구조를 채택.\n\nhttps://www.thegeekdiary.com/beginners-guide-to-managing-package-module-streams-in-centos-rhel-8/\nhttps://access.redhat.com/documentation/ko-kr/red_hat_enterprise_linux/8/html/installing_managing_and_removing_user-space_components/introduction-to-modules_using-appstream#module-streams_introduction-to-modules\nhttps://access.redhat.com/documentation/ko-kr/red_hat_enterprise_linux/8/html/installing_managing_and_removing_user-space_components/installing-a-module-stream_installing-rhel-8-content\nhttps://unix.stackexchange.com/questions/603905/what-is-the-difference-between-a-yum-group-and-a-yum-module-in-red-hat-enterpris ## 네트워크\n\n네트워크 관리 방법이 서로 다름.\nRHEL 7은 network라는 서비스를 사용, network-scripts라는 스크립트를 작성함.\nRHEL 8은 NetworkManager라는 서비스를 사용 ==&gt; nmcli를 통해 관리. 예시) 네트워크 명명 규칙:\nRHEL 7에서: eth0 등.\nRHEL 8은 ’예측 가능한 네트워크 명명 규칙’을 도입 ==&gt; 가령, enpXXX (예: enp0s3) 형식을 사용.\nhttps://access.redhat.com/documentation/ko-kr/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index#consistent-network-interface-device-naming_configuring-and-managing-networking"
  },
  {
    "objectID": "posts/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8.html#관리-예시-eth0라는-인터페이스를-구성해보자",
    "href": "posts/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8.html#관리-예시-eth0라는-인터페이스를-구성해보자",
    "title": "2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8",
    "section": "",
    "text": "RHEL 7의 network-scripts 스크립트로 관리하기:\n\nDEVICE=eth0\nBOOTPROTO=static\nONBOOT=yes\nIPADDR=192.168.1.100\nNETMASK=255.255.255.0\nGATEWAY=192.168.1.1\nDNS1=8.8.8.8\nDNS2=8.8.4.4\n\nRHEL 8의 NetworkManager로 관리하기 (nmcli):\n\nnmcli device status\nnmcli con mod eth0 ipv4.addresses 192.168.1.100/24\nnmcli con mod eth0 ipv4.gateway 192.168.1.1\nnmcli con mod eth0 ipv4.dns \"8.8.8.8,8.8.4.4\"\nnmcli con mod eth0 ipv4.method manual\nnmcli con mod eth0 connection.autoconnect yes\nnmcli con down eth0\nnmcli con up eth0"
  },
  {
    "objectID": "posts/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8.html#컨테이너화",
    "href": "posts/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8/2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8.html#컨테이너화",
    "title": "2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8",
    "section": "",
    "text": "RHEL 7은 Docker 기반의 컨테이너화를 지원.\nRHEL 8은 Podman 등 기반의 컨테이너화를 지원. ## 스터디에서 RHEL 7 채택 이유\n금융권뿐만 아니라 대규모 시스템에서는 사후지원 종료 후에도 유지하는 경우가 많음.\n시스템의 안정성 및 기존 기술의 숙련. ## 다음 주 화요일까지?\n구글 트렌드, 스택오버플로 자료량, 깃허브 스타 등.\n화요일 ==&gt; 1시간 전체 PPT 발표, 수요일==&gt; 실습.\n화요일 주제: ESXi에 설치하기 위한 가상매모리, UEFI 등, 고려해야 할 요소?\n\n시스템 요구사항: RHEL 7의 요구되는 하드웨어 사양?\n네트워크 설정: VMWare 환경에서 RHEL 7의 네트워크 구성?\n스토리지 관리: 사용할 스토리지 타입 및 구성 방법?\n가상화 특성 고려: RHEL 7을 VMWare ESXi에 설치할 때 가상화 특성 및 호환성?"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "끝없는 사랑과 끌어안음."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "무한포옹 《無限抱擁》",
    "section": "",
    "text": "Elasticsearch 및 Kibana\n\n\n2024.3.19. 수업 내용\n\n\n\nNoSQL\n\n\n\n\n\n\n\n\n\nMar 19, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\nAWS ALB로 로드밸런싱\n\n\n2024.3.08. 수업 후 미션.\n\n\n\nCloud\n\n\nCloud/AWS\n\n\n\n\n\n\n\n\n\nMar 8, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\nQuarto 블로그 예시 몇 가지\n\n\n\n\n\n\ncode\n\n\netc\n\n\n\n\n\n\n\n\n\nFeb 28, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\nJenkins 및 Pipeline으로 GitHub 연동\n\n\nJenkins 개념 및 실습.\n\n\n\nCI_CD\n\n\nJenkins\n\n\n\n\n\n\n\n\n\nFeb 20, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.30. 현장실습\n\n\n우리FISA 현장실습 대한 노트.\n\n\n\n현장\n\n\n특강\n\n\n\n\n\n\n\n\n\nJan 30, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.2.19. 취업 및 포트폴리오 특강\n\n\n우리FISA 특강 - 취업 및 포트폴리오 특강.\n\n\n\n현장\n\n\n특강\n\n\n\n\n\n\n\n\n\nJan 30, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\nVMware HA 및 DRS\n\n\nVMware HA 및 DRS 대한 수업 노트.\n\n\n\nVirtualization\n\n\n\n\n\n\n\n\n\nJan 27, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\nVMware 마이그레이션\n\n\nVMware로의 마이그레이션에 대한 수업 노트.\n\n\n\nVirtualization\n\n\n\n\n\n\n\n\n\nJan 25, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\nVMware 개요 및 HOL\n\n\nVMware에 대해서 알아보고, 이를 실습하기 위한 HOL에 접속해보자.\n\n\n\nVirtualization\n\n\n\n\n\n\n\n\n\nJan 22, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.19. 다이나믹 라우팅：OSPF (실습)\n\n\n2024.1.19. 수업 후 미션.\n\n\n\nNetworks\n\n\n\n\n\n\n\n\n\nJan 19, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.18. VirtualBox의 VM에서 내부망으로 연결\n\n\n2024.1.17. 수업 후 미션.\n\n\n\nNetworks\n\n\n\n\n\n\n\n\n\nJan 18, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.17. VirtualBox의 VM에서 내부망으로 연결\n\n\n2024.1.17. 수업 후 미션.\n\n\n\nVirtualization\n\n\n\n\n\n\n\n\n\nJan 17, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.16. Cisco 스위치 및 라우터 공장초기화\n\n\n스위치나 라우터의 공장초기화가 필요할 때도 있다.\n\n\n\nNetworks\n\n\n\n\n\n\n\n\n\nJan 16, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.16. VLAN 및 Static Routing 미션\n\n\n2024.1.16. 수업 후 미션.\n\n\n\nNetworks\n\n\n\n\n\n\n\n\n\nJan 16, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.16. 네트워크 이중화\n\n\n네트워크를 이중화하여 장애 등에 대비하자.\n\n\n\nNetworks\n\n\n\n\n\n\n\n\n\nJan 16, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.15. Layer 2 & Layer 3\n\n\nOSI 7계층 중 layer 2 및 layer 3에 대하여.\n\n\n\nNetworks\n\n\n\n\n\n\n\n\n\nJan 15, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.12. 셸 스크립팅\n\n\nLinux를 배울 때 필수적인 셸 스크립팅.\n\n\n\nLinux\n\n\n\n\n\n\n\n\n\nJan 12, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n2024.1.10. OS 선택하기 - RHEL 7 Vs. RHEL 8\n\n\n서버를 구성한다고 가정할 때, RHEL 7과 8을 비교해보자.\n\n\n\nLinux\n\n\n\n\n\n\n\n\n\nJan 10, 2024\n\n\nMugen-Houyou\n\n\n\n\n\n\n\n\n\n\n\n\n안녕하세요. 무한포옹 《無限抱擁》입니다.\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 15, 2023\n\n\nMugen-Houyou\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html",
    "href": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html",
    "title": "2024.1.12. 셸 스크립팅",
    "section": "",
    "text": "노트 작성 일자: 2024년 1월 12일 (수) 09:49"
  },
  {
    "objectID": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#셸-스크립팅이란",
    "href": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#셸-스크립팅이란",
    "title": "2024.1.12. 셸 스크립팅",
    "section": "셸 스크립팅이란?",
    "text": "셸 스크립팅이란?\n\n커맨드 라인을 통해 운영 체제에 명령을 자동화하는 스크립트."
  },
  {
    "objectID": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#셸-스크립트-언어의-종류",
    "href": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#셸-스크립트-언어의-종류",
    "title": "2024.1.12. 셸 스크립팅",
    "section": "셸 스크립트 언어의 종류",
    "text": "셸 스크립트 언어의 종류\n\nSh\n\nPOSIX 표준 쉘 스크립트.\n대부분의 UNIX 시스템에서 지원.\n\nBash\n\nGNU 프로젝트의 일부.\n향상된 기능을 제공하며 사용자 친화적.\n\nZsh\n\n사용자 인터페이스 및 기능 향상에 중점.\n\nPowerShell\n\n마이크로소프트 윈도우에 특화.\n객체 지향적 명령어 접근 방식."
  },
  {
    "objectID": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#bash란",
    "href": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#bash란",
    "title": "2024.1.12. 셸 스크립팅",
    "section": "Bash란?",
    "text": "Bash란?\n\nBourne-again Shell.\nGNU 프로젝트의 일환으로 개발된 유닉스 셸.\n스크립트 작성 및 명령 실행에 널리 사용됨."
  },
  {
    "objectID": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#왜-bash를-사용하는가",
    "href": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#왜-bash를-사용하는가",
    "title": "2024.1.12. 셸 스크립팅",
    "section": "왜 Bash를 사용하는가?",
    "text": "왜 Bash를 사용하는가?\n\n널리 사용되고, 강력하며, 사용자 친화적."
  },
  {
    "objectID": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#bourne-shell-vs.-bourne-again-shell",
    "href": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#bourne-shell-vs.-bourne-again-shell",
    "title": "2024.1.12. 셸 스크립팅",
    "section": "Bourne Shell vs. Bourne-again Shell?",
    "text": "Bourne Shell vs. Bourne-again Shell?\n\nBash는 Bourne Shell의 확장 버전으로, 개선된 문법을 제공함."
  },
  {
    "objectID": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#bash-사용법-및-문법",
    "href": "posts/2024.1.12. Bash 스크립팅/2024.1.12. Bash 스크립팅.html#bash-사용법-및-문법",
    "title": "2024.1.12. 셸 스크립팅",
    "section": "Bash 사용법 및 문법",
    "text": "Bash 사용법 및 문법\n\n변수 지정 및 사용\n\n변수명=값 형식으로 지정.\n$변수명으로 사용.\n\nmy_var=\"Hello, World!\"\necho $my_var  # Outputs: Hello, World!\n\n\n사용자로부터 입력받기\n\nread 변수명 명령어 사용.\n\necho \"Enter your name: \"\nread name\necho \"Hello, $name!\"\n\n\n파라미터 받기 및 전달\n\n스크립트 내 $1, $2 등으로 접근.\n\n# Suppose this is in a script called greet.sh\necho \"Hello, $1!\"\n# When you run `bash greet.sh John`, it will output: Hello, John!\n\n\n산술 연산\n\nlet, expr, 또는 (( 연산 )) 사용.\n\nlet result=5+3\necho $result  # Outputs: 8\n\nresult=$(expr 5 + 3)\necho $result  # Outputs: 8\n\nresult=$((5 + 3))\necho $result  # Outputs: 8\n\n\nif 조건문\n\nif [ 조건 ]; then ... fi 구조 사용.\n\nnumber=10\nif [ $number -eq 10 ]; then\n    echo \"숫자의 값은: 10.\"\nelse\n    echo \"숫자의 값은 10이 아님.\"\nfi\n\n# 문자열 비교\nif [ \"$a\" == \"$b\" ]; then\n    echo \"a와 b는 같음.\"\nfi\n\n# 숫자 비교\nif [ $a -gt $b ]; then\n    echo \"a는 b보다 큽니다.\"\nelif [ $a -eq $b ]; then\n    echo \"a와 b는 같습니다.\"\nelse\n    echo \"a는 b보다 작습니다.\"\nfi\n\n# 파일 존재 여부 확인\nif [ -f \"$file\" ]; then\n    echo \"$file 파일 이미 존재함.\"\nfi\n\n## AND 및 OR 연산자\nif [ $a -gt 10 ] && [ $b -lt 5 ]; then\n    echo \"a는 10보다 크고 b는 5보다 작습니다.\"\nfi\n\nif [ $a -gt 10 ] || [ $b -lt 5 ]; then\n    echo \"a가 10보다 크거나 b가 5보다 작습니다.\"\nfi\n\nif [[ 조건 ]]; then ... fi 구조 ==&gt; sh에서는 지원하지 않고, bash부터 사용 가능.\n\nstr1=\"Hello\"\nstr2=\"World\"\n\n# [[]]에서는 변수 사용 시 \"\" 안 써도 됨.\nif [[ $str1 == $str2 ]]; then\n    echo \"String들이 같다.\"\nelse\n    echo \"String들이 다르다.\"\nfi\nfilename=\"example.txt\"\nif [[ $filename == *.txt ]]; then\n    echo \"$filename is a text file.\"\nelse\n    echo \"$filename is not a text file.\"\nfi\n\n# NOT 사용하기.\nstr=\"Hello\"\nif [[ ! $str == \"World\" ]]; then\n    echo \"$str is not World.\"\nfi\n\n\ncase문\ncase $var in\n    1) echo \"Number 1\";;\n    2) echo \"Number 2\";;\n    3) echo \"Number 3\";;\n    *) echo \"Other number\";;\nesac\n\n\n반복문\n\nfor, while, until 반복문 사용 가능.\n\n# Using for loop\nfor i in {1..5}\ndo\n   echo \"Welcome $i times\"\ndone\n\n# Using while loop\ncount=5\nwhile [ $count -gt 0 ]; do\n  echo \"Countdown: $count\"\n  let count=count-1\ndone\n\n\n배열\n\n배열명=(요소1 요소2 ...) 형식으로 선언.\n${배열명[인덱스]}로 접근.\nmyArray=( \"$@\" ) ==&gt; 파라미터들을 받아서 배열로 선언.\n\n# 가령, $ ./arraypractice.sh \"탐험\" 사모예드 \"개마고원\" \"적설량 100cm\" \"개발자\"\n# 위와 같이 입력받아서, \"탐험\"부터 \"개발자\"를 파싱 및 배열로 선언,\n# sort 후 각 배열의 문자열을 \\n으로 끊어 출력함.\nmyArray=( \"$@\" )\nprintf \"%s\\n\" \"${myArray[@]}\" | sort"
  },
  {
    "objectID": "posts/2024.1.16. Cisco 스위치 및 라우터 공장초기화/2024.1.16. Cisco 스위치 및 라우터 공장초기화.html",
    "href": "posts/2024.1.16. Cisco 스위치 및 라우터 공장초기화/2024.1.16. Cisco 스위치 및 라우터 공장초기화.html",
    "title": "2024.1.16. Cisco 스위치 및 라우터 공장초기화",
    "section": "",
    "text": "Cisco 스위치 및 라우터 공장초기화하기\n주의: 스위치와 라우터의 공장초기화 방법이 서로 다름.\n\nSwitch\n\nen\nerase nvram:\ndelete flash:vlan.dat\nreload\n\nRouter\n\nen\nerase nvram:\nreload"
  },
  {
    "objectID": "posts/2024.1.16. 네트워크 이중화/2024.1.16. 네트워크 이중화.html",
    "href": "posts/2024.1.16. 네트워크 이중화/2024.1.16. 네트워크 이중화.html",
    "title": "2024.1.16. 네트워크 이중화",
    "section": "",
    "text": "노트 작성 일자: 2024년 1월 16일 (수) 09:06"
  },
  {
    "objectID": "posts/2024.1.16. 네트워크 이중화/2024.1.16. 네트워크 이중화.html#폐구조",
    "href": "posts/2024.1.16. 네트워크 이중화/2024.1.16. 네트워크 이중화.html#폐구조",
    "title": "2024.1.16. 네트워크 이중화",
    "section": "폐구조",
    "text": "폐구조"
  },
  {
    "objectID": "posts/2024.1.16. 네트워크 이중화/2024.1.16. 네트워크 이중화.html#stp-spanning-tree-protocol",
    "href": "posts/2024.1.16. 네트워크 이중화/2024.1.16. 네트워크 이중화.html#stp-spanning-tree-protocol",
    "title": "2024.1.16. 네트워크 이중화",
    "section": "STP (Spanning Tree Protocol)",
    "text": "STP (Spanning Tree Protocol)\n\n\nSTP란?\nSuboptimal path 문제\n\n원인: broadcast domain이 1개\n해결책: 라우터를 하나 둬서 네트워크를 분리하기."
  },
  {
    "objectID": "posts/2024.1.16. 네트워크 이중화/2024.1.16. 네트워크 이중화.html#etherchannel",
    "href": "posts/2024.1.16. 네트워크 이중화/2024.1.16. 네트워크 이중화.html#etherchannel",
    "title": "2024.1.16. 네트워크 이중화",
    "section": "EtherChannel",
    "text": "EtherChannel\n\nEtherChannel이란?\n이점:\n\n대역폭이 링크만큼 늘어남.\n트래픽의 로드 밸런싱.\n링크 중 하나가 죽으면 트래픽이 나머지 살아있는 쪽으로 다 넘어감.\n\n주의점:\n\nGigabit Ethernet과 Fast Ethernet가 같이 묶일 수 없음.\nVLAN 구성이 아예 동일해야 함. 예시: 1,5,10이랑 1,10인 두 개의 포트는 묶일 수 없음.\n장비마다 스펙 참고해야 함 ==&gt; 어떤 장비는 최대 6개 선만 지원.\n\nServer-side에서는 teamming.\nEtherChannel의 프로토콜들:\n\nLACP (Link Aggregation Control Protocol)\n\n\n\n\n\n\n표준 프로토콜\n참고: 양쪽 스위치에 둘 다 적용해야 함.\n적용 전후 비교 (sh spanning-tree): \n\nPAgP (Port Aggregation Protocol)\n\n시스코 proprietary 프로토콜"
  },
  {
    "objectID": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html",
    "href": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html",
    "title": "VMware 개요 및 HOL",
    "section": "",
    "text": "물리적인 하드웨어의 논리적인 표현.\n단일 물리적 컴퓨터에서 여러 시스템들을 동시에 실행 가능.\n서버 가상화, 테스트 환경, 시스템 이전 및 보안 목적 등 다양한 용도로 사용됨.\n\n\n\n\n\nHypervisor: 하드웨어와 가상 머신 사이에서 작동하는 소프트웨어 또는 펌웨어 계층.\nDatastore: 가상 머신 파일을 저장하는 물리적 저장소 리소스.\n\n\n\n\n\nWorkstation: 개인 사용자를 위한 가상화 솔루션.\nFusion: 맥 사용자를 위한 가상화 솔루션.\nvSphere: VMware의 클라우드 컴퓨팅 가상화 플랫폼.\nvCenter Server: 중앙 집중식 관리 애플리케이션, 다수의 ESXi 호스트 및 가상 머신을 관리.\nvSAN: 가상화된 스토리지 솔루션, 하드웨어 스토리지의 필요성을 줄임.\nHorizon: 가상 데스크톱 인프라(VDI) 솔루션.\nNSX: 네트워크 가상화 및 보안 플랫폼.\nAirWatch: 엔터프라이즈 모빌리티 관리(EMM) 솔루션.\n\n\n\n\n\n정의: VMware의 엔터프라이즈급, 베어 메탈 (bare metal) 하이퍼바이저.\n특징: 직접 서버 하드웨어에 설치되며, 가상화된 환경을 효율적으로 관리 및 분배. 높은 성능, 확장성, 보안성 제공.\n\n\n\n\n\n정의: 가상 머신을 한 서버에서 다른 서버로 이동시키는 기능.\n특징: 가동 중인 가상 머신을 다운타임 없이 이전. 유지보수, 로드 밸런싱, 재해 복구 계획에 유용.\n\n\n\n\n\nvSwitch란?\n\n가상 스위치로, 가상 환경 내 네트워크 트래픽을 관리하는 소프트웨어 기반 스위치.\n네트워크 분리 및 격리, 보안 정책 구현, 트래픽 관리 및 모니터링 등.\n\n역할\n\n1개 host 내 VM들간 통신\n여러 hosts의 VM들간 통신\n스토리지 연결\n관리용\nvMotion ## Thin Provisioning Vs. Thick Provisioning 스토리지 관리와 관련된 개념.\n\nThin Provisioning: 물리적 스토리지 공간을 가상 머신에 실제 사용량만큼만 할당하는 방식. 자원의 효율적인 사용을 가능하게 함.\n\n주의사항: 과도한 오버프로비저닝으로 저장소 공간 부족 발생 가능.\n\nThick Provisioning: 필요한 스토리지 공간을 미리 전체 할당하는 방식. 성능은 더 좋지만, 스토리지 공간의 낭비 가능성이 있음.\n\n\n\n\n이건 클라이언트 컴퓨팅 모델과 관련이 있음. - Thin Client: 가볍고 기능이 제한된 클라이언트 컴퓨터. 중앙 서버에 의존적으로 작동하며, 주로 데이터 처리와 저장을 서버에서 수행. 저렴한 유지비 (클라이언트가), 중앙 집중식 관리, 보안성 강화. - Thick Client (Fat Client): 모든 연산을 로컬에서 수행하는 전통적인 컴퓨터 모델. 오프라인 작업 가능, UX적으로 좋음."
  },
  {
    "objectID": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#가상-머신",
    "href": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#가상-머신",
    "title": "VMware 개요 및 HOL",
    "section": "",
    "text": "물리적인 하드웨어의 논리적인 표현.\n단일 물리적 컴퓨터에서 여러 시스템들을 동시에 실행 가능.\n서버 가상화, 테스트 환경, 시스템 이전 및 보안 목적 등 다양한 용도로 사용됨."
  },
  {
    "objectID": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-용어-몇-가지",
    "href": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-용어-몇-가지",
    "title": "VMware 개요 및 HOL",
    "section": "",
    "text": "Hypervisor: 하드웨어와 가상 머신 사이에서 작동하는 소프트웨어 또는 펌웨어 계층.\nDatastore: 가상 머신 파일을 저장하는 물리적 저장소 리소스."
  },
  {
    "objectID": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-주요-솔루션",
    "href": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-주요-솔루션",
    "title": "VMware 개요 및 HOL",
    "section": "",
    "text": "Workstation: 개인 사용자를 위한 가상화 솔루션.\nFusion: 맥 사용자를 위한 가상화 솔루션.\nvSphere: VMware의 클라우드 컴퓨팅 가상화 플랫폼.\nvCenter Server: 중앙 집중식 관리 애플리케이션, 다수의 ESXi 호스트 및 가상 머신을 관리.\nvSAN: 가상화된 스토리지 솔루션, 하드웨어 스토리지의 필요성을 줄임.\nHorizon: 가상 데스크톱 인프라(VDI) 솔루션.\nNSX: 네트워크 가상화 및 보안 플랫폼.\nAirWatch: 엔터프라이즈 모빌리티 관리(EMM) 솔루션."
  },
  {
    "objectID": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-esxi",
    "href": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-esxi",
    "title": "VMware 개요 및 HOL",
    "section": "",
    "text": "정의: VMware의 엔터프라이즈급, 베어 메탈 (bare metal) 하이퍼바이저.\n특징: 직접 서버 하드웨어에 설치되며, 가상화된 환경을 효율적으로 관리 및 분배. 높은 성능, 확장성, 보안성 제공."
  },
  {
    "objectID": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-vmotion",
    "href": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-vmotion",
    "title": "VMware 개요 및 HOL",
    "section": "",
    "text": "정의: 가상 머신을 한 서버에서 다른 서버로 이동시키는 기능.\n특징: 가동 중인 가상 머신을 다운타임 없이 이전. 유지보수, 로드 밸런싱, 재해 복구 계획에 유용."
  },
  {
    "objectID": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-vswitch",
    "href": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#vmware-vswitch",
    "title": "VMware 개요 및 HOL",
    "section": "",
    "text": "vSwitch란?\n\n가상 스위치로, 가상 환경 내 네트워크 트래픽을 관리하는 소프트웨어 기반 스위치.\n네트워크 분리 및 격리, 보안 정책 구현, 트래픽 관리 및 모니터링 등.\n\n역할\n\n1개 host 내 VM들간 통신\n여러 hosts의 VM들간 통신\n스토리지 연결\n관리용\nvMotion ## Thin Provisioning Vs. Thick Provisioning 스토리지 관리와 관련된 개념.\n\nThin Provisioning: 물리적 스토리지 공간을 가상 머신에 실제 사용량만큼만 할당하는 방식. 자원의 효율적인 사용을 가능하게 함.\n\n주의사항: 과도한 오버프로비저닝으로 저장소 공간 부족 발생 가능.\n\nThick Provisioning: 필요한 스토리지 공간을 미리 전체 할당하는 방식. 성능은 더 좋지만, 스토리지 공간의 낭비 가능성이 있음."
  },
  {
    "objectID": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#번외.-thin-client-vs.-thick-client",
    "href": "posts/2024.1.22. VMware HOL/2024.1.22. VMware HOL.html#번외.-thin-client-vs.-thick-client",
    "title": "VMware 개요 및 HOL",
    "section": "",
    "text": "이건 클라이언트 컴퓨팅 모델과 관련이 있음. - Thin Client: 가볍고 기능이 제한된 클라이언트 컴퓨터. 중앙 서버에 의존적으로 작동하며, 주로 데이터 처리와 저장을 서버에서 수행. 저렴한 유지비 (클라이언트가), 중앙 집중식 관리, 보안성 강화. - Thick Client (Fat Client): 모든 연산을 로컬에서 수행하는 전통적인 컴퓨터 모델. 오프라인 작업 가능, UX적으로 좋음."
  },
  {
    "objectID": "posts/2024.1.27. VMware HA 및 DRS/2024.1.27. VMware HA 및 DRS.html",
    "href": "posts/2024.1.27. VMware HA 및 DRS/2024.1.27. VMware HA 및 DRS.html",
    "title": "VMware HA 및 DRS",
    "section": "",
    "text": "VMware HA란?\n\nVMware ESX 호스트에서 고가용성을 제공하는 기능.\n클러스터 내 모든 ESX 서버 호스트를 지속적으로 모니터링하고 장애를 감지함.\n\n작동 원리:\n\n각 호스트에 배치된 에이전트가 클러스터 내 다른 호스트들과 “하트비트”를 유지함.\n하트비트 손실 시, 영향받은 가상 머신들이 다른 호스트로 재시작됨.\nVirtualCenter 관리 서버가 클러스터 내 각 호스트에 에이전트를 배치하여 상태 정보를 유지하고 다른 호스트의 실패 시 대응함.\n\n장애 감지: 하트비트 송신 중단 후 15초 후에 호스트 실패로 간주함.\n네트워크 격리: 호스트가 네트워크에서 격리될 경우 기본적으로 가상 머신을 종료하며, SAN 접근이 가능한 경우 디스크 잠금을 유지함.\n기본 동작: 네트워크 연결이 복구되기 전에는 가상 머신이 다른 호스트로 재시작되지 않습니다.\n유지보수, 로드 밸런싱, 재해 복구 계획 등에 유용.\n\n\n\n\n\nVMware DRS란?\n\nVMware ESXi 호스트 클러스터 내에서 최적의 리소스 사용과 부하 균형을 위한 클러스터링 기능.\n\n기능:\n\n부하가 많은 ESXi 호스트에서 부하가 적은 호스트로 가상 머신(VM)을 마이그레이션하여 부하 균형.\n가상 머신의 초기 배치, 부하 균형, 클러스터 유지 관리 등을 자동화함.\n\n주요 특징:\n\n가상 머신의 워크로드를 클러스터 내 vSphere 호스트에 분산.\n리소스 사용 최적화 및 전력 소비 절감 기능.\n유지보수 중에도 서비스 중단 없이 가상 머신 배포 가능.\n\n자동 로드 밸런싱: DRS는 클러스터 내 호스트 간에 가상 머신 워크로드를 분산시키고 자원을 모니터링함."
  },
  {
    "objectID": "posts/2024.1.27. VMware HA 및 DRS/2024.1.27. VMware HA 및 DRS.html#vmware-ha-high-availability",
    "href": "posts/2024.1.27. VMware HA 및 DRS/2024.1.27. VMware HA 및 DRS.html#vmware-ha-high-availability",
    "title": "VMware HA 및 DRS",
    "section": "",
    "text": "VMware HA란?\n\nVMware ESX 호스트에서 고가용성을 제공하는 기능.\n클러스터 내 모든 ESX 서버 호스트를 지속적으로 모니터링하고 장애를 감지함.\n\n작동 원리:\n\n각 호스트에 배치된 에이전트가 클러스터 내 다른 호스트들과 “하트비트”를 유지함.\n하트비트 손실 시, 영향받은 가상 머신들이 다른 호스트로 재시작됨.\nVirtualCenter 관리 서버가 클러스터 내 각 호스트에 에이전트를 배치하여 상태 정보를 유지하고 다른 호스트의 실패 시 대응함.\n\n장애 감지: 하트비트 송신 중단 후 15초 후에 호스트 실패로 간주함.\n네트워크 격리: 호스트가 네트워크에서 격리될 경우 기본적으로 가상 머신을 종료하며, SAN 접근이 가능한 경우 디스크 잠금을 유지함.\n기본 동작: 네트워크 연결이 복구되기 전에는 가상 머신이 다른 호스트로 재시작되지 않습니다.\n유지보수, 로드 밸런싱, 재해 복구 계획 등에 유용."
  },
  {
    "objectID": "posts/2024.1.27. VMware HA 및 DRS/2024.1.27. VMware HA 및 DRS.html#vmware-drs-distributed-resource-scheduler",
    "href": "posts/2024.1.27. VMware HA 및 DRS/2024.1.27. VMware HA 및 DRS.html#vmware-drs-distributed-resource-scheduler",
    "title": "VMware HA 및 DRS",
    "section": "",
    "text": "VMware DRS란?\n\nVMware ESXi 호스트 클러스터 내에서 최적의 리소스 사용과 부하 균형을 위한 클러스터링 기능.\n\n기능:\n\n부하가 많은 ESXi 호스트에서 부하가 적은 호스트로 가상 머신(VM)을 마이그레이션하여 부하 균형.\n가상 머신의 초기 배치, 부하 균형, 클러스터 유지 관리 등을 자동화함.\n\n주요 특징:\n\n가상 머신의 워크로드를 클러스터 내 vSphere 호스트에 분산.\n리소스 사용 최적화 및 전력 소비 절감 기능.\n유지보수 중에도 서비스 중단 없이 가상 머신 배포 가능.\n\n자동 로드 밸런싱: DRS는 클러스터 내 호스트 간에 가상 머신 워크로드를 분산시키고 자원을 모니터링함."
  },
  {
    "objectID": "posts/2024.2.19. 취업 및 포트폴리오 특강/2024.2.19. 취업 및 포트폴리오 특강.html",
    "href": "posts/2024.2.19. 취업 및 포트폴리오 특강/2024.2.19. 취업 및 포트폴리오 특강.html",
    "title": "2024.2.19. 취업 및 포트폴리오 특강",
    "section": "",
    "text": "예시 포트폴리오. 출처\n\n\n\n\n\n기술 스택 관련\n개발 프로젝트 및 경험\n\n커뮤니케이션\n\n역할을 바꿔서 해보기\n갈등 조정 및 해결\n결국 리더를 해봐라.\n\n\nGitHub 및 포트폴리오\n협업 경험 어필\n\n인수인계 등 타인에 대한 배려\n얘기를 많이 해보기\n아이디어 ==&gt; 공유\n\n자격증\n\n현업에선 큰 의미 없다\n그러나, 성실함을 보여주는 척도\n남들보다, 여가시간에 이런 걸 했다. 기본적인 건 한다. 성실하다. 등 어필\n\n수상 경험\n\n타전공자의 경우, 그 경험이 활용될 수도 있다\n수상 경험도 이와 마찬가지 ==&gt; 다 넣어라\n수상한 이벤트로부터 회고하기\n\n회고를 통해 다음 프로젝트에서 기초를 개선\n회고를 해야 수상한 것도 어필할 거리가 생긴다\n\n\n일정\n\n‘이거 … 에 얼마나 걸리겠니?’\n\n리더십\n개발자로서의 성장 및 러닝 커브\n\n매일마다 기록, readme.md 작성\n배운 것과 배우지 않은 것\n\n인재상\n\n본인의 스토리를 최대한 만들어서 해당 회사의 인재상에 맞추는 것\n신생 기업에 경우 “우리 회사에 대해 아는 게 있으세요?”\n\n진심이 느껴지는 것들\n\n\n기술에 대한 어필\n\n신입에게 많은 걸 바라지 않는다.\n해당 기술을 선택한 이유, 고민\n남들이 보기 어려운 depth까지 예) 프레임워크의 실제 소스를 까보기\n\n\n\n\n\n\n스타트업 - 내 개발 ==&gt; 매출로, 책임감, 비용 관련, 등\n중소기업 - “중소기업을” 많이 알기, 생각보다 좋은 회사가 많다 ==&gt; 이때 “우리 회사 아세요?” 중요, 직원수 많은 게 좋을 수도 있음\n중견기업 - (연혁 많다) 적응력,\n대기업\n연혁 짧은 회사\n연혁 긴 회사\n영업이익 많은 회사\n영업이익 적은 회사\nSI/솔루션/플랫폼(서비스)\n\nSI는 데드라인 일정 맞추기에 바쁘다. 압박감 심함 ==&gt; 주말, 야근, 등\n\n구디, 가디 등\n\n솔루션이나 플랫폼은 좀 나을 수도 있다. 즉, 자기껄 만드는 회사가 좀 더 기술력이 있다\n\n\n\n\n\n어떤 게 좋은 회사, 나쁜 회사를 구별하는가?\n\n기술 블로그, 툴의 전폭적 지원 (예: Intellij, AWS, 장비)"
  },
  {
    "objectID": "posts/2024.2.19. 취업 및 포트폴리오 특강/2024.2.19. 취업 및 포트폴리오 특강.html#표현하기",
    "href": "posts/2024.2.19. 취업 및 포트폴리오 특강/2024.2.19. 취업 및 포트폴리오 특강.html#표현하기",
    "title": "2024.2.19. 취업 및 포트폴리오 특강",
    "section": "",
    "text": "기술 스택 관련\n개발 프로젝트 및 경험\n\n커뮤니케이션\n\n역할을 바꿔서 해보기\n갈등 조정 및 해결\n결국 리더를 해봐라.\n\n\nGitHub 및 포트폴리오\n협업 경험 어필\n\n인수인계 등 타인에 대한 배려\n얘기를 많이 해보기\n아이디어 ==&gt; 공유\n\n자격증\n\n현업에선 큰 의미 없다\n그러나, 성실함을 보여주는 척도\n남들보다, 여가시간에 이런 걸 했다. 기본적인 건 한다. 성실하다. 등 어필\n\n수상 경험\n\n타전공자의 경우, 그 경험이 활용될 수도 있다\n수상 경험도 이와 마찬가지 ==&gt; 다 넣어라\n수상한 이벤트로부터 회고하기\n\n회고를 통해 다음 프로젝트에서 기초를 개선\n회고를 해야 수상한 것도 어필할 거리가 생긴다\n\n\n일정\n\n‘이거 … 에 얼마나 걸리겠니?’\n\n리더십\n개발자로서의 성장 및 러닝 커브\n\n매일마다 기록, readme.md 작성\n배운 것과 배우지 않은 것\n\n인재상\n\n본인의 스토리를 최대한 만들어서 해당 회사의 인재상에 맞추는 것\n신생 기업에 경우 “우리 회사에 대해 아는 게 있으세요?”\n\n진심이 느껴지는 것들\n\n\n기술에 대한 어필\n\n신입에게 많은 걸 바라지 않는다.\n해당 기술을 선택한 이유, 고민\n남들이 보기 어려운 depth까지 예) 프레임워크의 실제 소스를 까보기"
  },
  {
    "objectID": "posts/2024.2.19. 취업 및 포트폴리오 특강/2024.2.19. 취업 및 포트폴리오 특강.html#회사-함께-생각해보기",
    "href": "posts/2024.2.19. 취업 및 포트폴리오 특강/2024.2.19. 취업 및 포트폴리오 특강.html#회사-함께-생각해보기",
    "title": "2024.2.19. 취업 및 포트폴리오 특강",
    "section": "",
    "text": "스타트업 - 내 개발 ==&gt; 매출로, 책임감, 비용 관련, 등\n중소기업 - “중소기업을” 많이 알기, 생각보다 좋은 회사가 많다 ==&gt; 이때 “우리 회사 아세요?” 중요, 직원수 많은 게 좋을 수도 있음\n중견기업 - (연혁 많다) 적응력,\n대기업\n연혁 짧은 회사\n연혁 긴 회사\n영업이익 많은 회사\n영업이익 적은 회사\nSI/솔루션/플랫폼(서비스)\n\nSI는 데드라인 일정 맞추기에 바쁘다. 압박감 심함 ==&gt; 주말, 야근, 등\n\n구디, 가디 등\n\n솔루션이나 플랫폼은 좀 나을 수도 있다. 즉, 자기껄 만드는 회사가 좀 더 기술력이 있다\n\n\n\n\n\n어떤 게 좋은 회사, 나쁜 회사를 구별하는가?\n\n기술 블로그, 툴의 전폭적 지원 (예: Intellij, AWS, 장비)"
  },
  {
    "objectID": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html",
    "href": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html",
    "title": "AWS ALB로 로드밸런싱",
    "section": "",
    "text": "🏷️ Tags: #03-2024 #Cloud #Cloud/AWS\n\n\n\n\n로드밸런싱이란?\n\n여러 서버에 네트워크 트래픽이나 요청을 분산하여 처리하는 기술.\n기존의 단일 서버에서 발생할 수 있는 과부하를 방지하고, 애플리케이션의 고가용성 (HA) 및 재해 복구 (DR)를 달성.\n이 포스트에서 다룰 AWS의 Application Load Balancer (ALB)는 OSI 모델의 7계층에서 작동하여, ‘health check’ 기능을 통해 각 대상의 현재 상태를 모니터링하고, 문제가 있는 서버로부터 트래픽을 자동으로 분리. 이러한 솔루션을 통해 HTTP 및 HTTPS 트래픽을 유연하게 전달 가능.\n\n\n\n\n예시 출처🔗\n\n\n\n\n\n\n\n\n리전 확인\n\n\n\n\n\n\n\n\n좌측상단의 Create VPC 클릭\n\nVPC and more 선택 후, AZ 1개, public subnet 1개, private subnets 0개,\n단, public subnet에 대한 CIDR block는 아래와 같이 구성 (10.0.10.0/24)\n\n이후 AP-NE-2c 리전에 10.0.20.0/24 subnet를 추가 생성\n\n\n\n\n생성된 두 개의 subnet에 대하여 라우팅 테이블 편집\nSubnet을 클릭 후 edit route table association 클릭\n\n이후 아래와 같이 Main route table이 아닌 라우팅 테이블을 선택 후 저장\n\n\n\n\n\n\n이 lab에서는 EC2 웹서버용 보안 그룹과 ALB용 보안 그룹, 총 2개를 생성해야 함\n그러나 이 항목에서는 EC2 웹서버용 보안 그룹만 생성함\nwebserver-sg에는 아래와 같이 inbound/outbound rules 지정 후 저장\n\n\n\n\n\n\n\n\n\n리전을 AP-NE-2a로 지정, t2.micro, 위에 생성한 VPC 및 webserver-sg 사용\nAuto-assign public IP를 Enable로 설정!\n단, Advanced details 항목의 맨 아래에 아래와 같이 웹서버로 구동되기 위한 초기 스크립트를 구성\n\n\n\n\n\n\n두 번째 인스턴스는 첫 번째 인스턴스를 이미지화한 AMI로부터 생성\n아래와 같이 Launch instance from AMI 클릭\n\n리전을 AP-NE-2c로 지정, t3.micro, 위에 생성한 VPC 및 webserver-sg 사용\nAuto-assign public IP를 Enable로 설정!\n\n\n\n\n\n2개 인스턴스 모두 http:///로 접속하여 웹서버 정상 작동 확인\n\n\n\n\n\n\n\n\n\n아래와 같이 좌측 첫 번째 항목을 선택하여 ALB 생성\n\n\n\n\n\n\n위 EC2 항목에서 언급한 대로 보안 그룹이 2개가 필요한데, 이 항목에서는 ALB에 대한 보안 그룹을 생성함\n다만, 이거 이후에도 한 번 더 보안 그룹을 수정해야 함\n아래와 같은 inbound/outbound rules를 기반으로 생성함\n\n\n\n\n\n\nTarget group는 아래와 같이 구성\n\n\n\n\n\n\n\n\n\n\nEC2 웹서버에 대한 보안 그룹을 수정해야 함\n아래와 같이 inbound rules를 수정함, 단, 규칙을 수정하는 것이 아니라 삭제 후 생성하는 식으로 해야 함\nEC2 웹서버의 보안 그룹 (webserver-sg)을 수정하는데, 아래와 같이, HTTP 및 HTTPS에 대하여, webalb-sg를 선택한 뒤 저장\n\n\n\n\n\n\n\n\n\n다시 로드밸런서 메뉴로 돌아와, 아래와 같이 DNS name 항목을 복사\n\n웹브라우저 주소창에 복붙하여 정상 작동 확인\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAMI 삭제\nALB 삭제\nTarget group 삭제\nSecurity groups 삭제\nVPC 삭제\n\n\n\n\n\n\nALB의 한계는 무엇인가?\n다른 로드 밸런서들은 어떤가?\n재난 복구 관점에서, AWS 데이터센터가 갑자기 세상에서 증발하더라도, 웹 서비스가 멀쩡하게 동작하게끔 하려면?"
  },
  {
    "objectID": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html#개요",
    "href": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html#개요",
    "title": "AWS ALB로 로드밸런싱",
    "section": "",
    "text": "로드밸런싱이란?\n\n여러 서버에 네트워크 트래픽이나 요청을 분산하여 처리하는 기술.\n기존의 단일 서버에서 발생할 수 있는 과부하를 방지하고, 애플리케이션의 고가용성 (HA) 및 재해 복구 (DR)를 달성.\n이 포스트에서 다룰 AWS의 Application Load Balancer (ALB)는 OSI 모델의 7계층에서 작동하여, ‘health check’ 기능을 통해 각 대상의 현재 상태를 모니터링하고, 문제가 있는 서버로부터 트래픽을 자동으로 분리. 이러한 솔루션을 통해 HTTP 및 HTTPS 트래픽을 유연하게 전달 가능.\n\n\n\n\n예시 출처🔗"
  },
  {
    "objectID": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html#step-by-step-튜토리얼",
    "href": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html#step-by-step-튜토리얼",
    "title": "AWS ALB로 로드밸런싱",
    "section": "",
    "text": "리전 확인\n\n\n\n\n\n\n\n\n좌측상단의 Create VPC 클릭\n\nVPC and more 선택 후, AZ 1개, public subnet 1개, private subnets 0개,\n단, public subnet에 대한 CIDR block는 아래와 같이 구성 (10.0.10.0/24)\n\n이후 AP-NE-2c 리전에 10.0.20.0/24 subnet를 추가 생성\n\n\n\n\n생성된 두 개의 subnet에 대하여 라우팅 테이블 편집\nSubnet을 클릭 후 edit route table association 클릭\n\n이후 아래와 같이 Main route table이 아닌 라우팅 테이블을 선택 후 저장\n\n\n\n\n\n\n이 lab에서는 EC2 웹서버용 보안 그룹과 ALB용 보안 그룹, 총 2개를 생성해야 함\n그러나 이 항목에서는 EC2 웹서버용 보안 그룹만 생성함\nwebserver-sg에는 아래와 같이 inbound/outbound rules 지정 후 저장\n\n\n\n\n\n\n\n\n\n리전을 AP-NE-2a로 지정, t2.micro, 위에 생성한 VPC 및 webserver-sg 사용\nAuto-assign public IP를 Enable로 설정!\n단, Advanced details 항목의 맨 아래에 아래와 같이 웹서버로 구동되기 위한 초기 스크립트를 구성\n\n\n\n\n\n\n두 번째 인스턴스는 첫 번째 인스턴스를 이미지화한 AMI로부터 생성\n아래와 같이 Launch instance from AMI 클릭\n\n리전을 AP-NE-2c로 지정, t3.micro, 위에 생성한 VPC 및 webserver-sg 사용\nAuto-assign public IP를 Enable로 설정!\n\n\n\n\n\n2개 인스턴스 모두 http:///로 접속하여 웹서버 정상 작동 확인\n\n\n\n\n\n\n\n\n\n아래와 같이 좌측 첫 번째 항목을 선택하여 ALB 생성\n\n\n\n\n\n\n위 EC2 항목에서 언급한 대로 보안 그룹이 2개가 필요한데, 이 항목에서는 ALB에 대한 보안 그룹을 생성함\n다만, 이거 이후에도 한 번 더 보안 그룹을 수정해야 함\n아래와 같은 inbound/outbound rules를 기반으로 생성함\n\n\n\n\n\n\nTarget group는 아래와 같이 구성\n\n\n\n\n\n\n\n\n\n\nEC2 웹서버에 대한 보안 그룹을 수정해야 함\n아래와 같이 inbound rules를 수정함, 단, 규칙을 수정하는 것이 아니라 삭제 후 생성하는 식으로 해야 함\nEC2 웹서버의 보안 그룹 (webserver-sg)을 수정하는데, 아래와 같이, HTTP 및 HTTPS에 대하여, webalb-sg를 선택한 뒤 저장\n\n\n\n\n\n\n\n\n\n다시 로드밸런서 메뉴로 돌아와, 아래와 같이 DNS name 항목을 복사\n\n웹브라우저 주소창에 복붙하여 정상 작동 확인"
  },
  {
    "objectID": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html#자원-반환",
    "href": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html#자원-반환",
    "title": "AWS ALB로 로드밸런싱",
    "section": "",
    "text": "AMI 삭제\nALB 삭제\nTarget group 삭제\nSecurity groups 삭제\nVPC 삭제"
  },
  {
    "objectID": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html#질문-및-토론",
    "href": "posts/2024.3.08. AWS ALB 실습하기/2024.3.8. AWS ALB 실습하기.html#질문-및-토론",
    "title": "AWS ALB로 로드밸런싱",
    "section": "",
    "text": "ALB의 한계는 무엇인가?\n다른 로드 밸런서들은 어떤가?\n재난 복구 관점에서, AWS 데이터센터가 갑자기 세상에서 증발하더라도, 웹 서비스가 멀쩡하게 동작하게끔 하려면?"
  },
  {
    "objectID": "posts/quarto-blogs-samples/index.html",
    "href": "posts/quarto-blogs-samples/index.html",
    "title": "Quarto 블로그 예시 몇 가지",
    "section": "",
    "text": "https://beamilz.com/\nhttps://minsuk-sung.github.io/\nhttps://rchemistblog.com/blog/posts/2023-01-19-quarto-intro/\nhttps://www.crumplab.com/blog/post_887_8_25_22_quartoblog/\n이상입니다. 끝."
  }
]